generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                   String                @id @default(cuid())
  name                 String?
  email                String                @unique
  password             String
  discretePin          String?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  image                String?
  generalSettings      Json?
  notificationSettings Json?
  privacySettings      Json?
  budgets              Budget[]
  categories           Category[]
  creditCards          CreditCard[]
  financialGoals       FinancialGoal[]
  investments          Investment[]
  passwordResetTokens  PasswordResetToken[]
  recurringExpenses    RecurringExpense[]
  transactionTemplates TransactionTemplate[]
  transactions         Transaction[]
  feedbacks            Feedback[]
  notifications        Notification[]
  notificationsRead    NotificationRead[]

  @@map("users")
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_reset_tokens")
}

model Transaction {
  id          String          @id @default(cuid())
  type        TransactionType
  category    String
  date        DateTime
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  userId      String
  description String?
  value       String?
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, date])
  @@index([userId, type])
  @@index([userId, category])
  @@map("transactions")
}

model Category {
  id        String          @id @default(cuid())
  name      String
  type      TransactionType
  icon      String
  color     String
  isDefault Boolean         @default(false)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  userId    String?
  user      User?           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([name, type, userId])
  @@map("categories")
}

model TransactionTemplate {
  id          String          @id @default(cuid())
  name        String
  description String?
  category    String
  type        TransactionType
  usageCount  Int             @default(0)
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  userId      String
  value       String?
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("transaction_templates")
}

model Investment {
  id                String         @id @default(cuid())
  type              InvestmentType
  name              String
  ticker            String?
  institution       String?
  notes             String?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  indexer           String?
  maturityDate      DateTime?
  userId            String
  averagePrice      String?
  currentPrice      String?
  currentValue      String?
  goalValue         String?
  interestRate      String?
  profitLoss        String?
  profitLossPercent String?
  quantity          String?
  totalInvested     String?
  user              User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  operations        Operation[]

  @@index([userId])
  @@index([userId, type])
  @@map("investments")
}

model Operation {
  id           String     @id @default(cuid())
  investmentId String
  type         String
  date         DateTime
  createdAt    DateTime   @default(now())
  fees         String?
  notes        String?
  price        String?
  quantity     String?
  total        String?
  investment   Investment @relation(fields: [investmentId], references: [id], onDelete: Cascade)

  @@index([investmentId, date])
  @@index([investmentId, type])
  @@map("operations")
}

model CreditCard {
  id         String    @id @default(cuid())
  name       String
  lastDigits String?
  closingDay Int       @default(1)
  dueDay     Int       @default(10)
  color      String    @default("#8B5CF6")
  isActive   Boolean   @default(true)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  userId     String
  limit      String?
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  invoices   Invoice[]

  @@index([userId, isActive])
  @@map("credit_cards")
}

model Invoice {
  id           String        @id @default(cuid())
  creditCardId String
  month        Int
  year         Int
  closingDate  DateTime
  dueDate      DateTime
  status       InvoiceStatus @default(open)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  paidAmount   String?
  total        String?
  creditCard   CreditCard    @relation(fields: [creditCardId], references: [id], onDelete: Cascade)
  purchases    Purchase[]

  @@unique([creditCardId, month, year])
  @@index([creditCardId, status])
  @@map("invoices")
}

model Purchase {
  id                 String   @id @default(cuid())
  invoiceId          String
  category           String
  date               DateTime
  installments       Int      @default(1)
  currentInstallment Int      @default(1)
  isRecurring        Boolean  @default(false)
  parentPurchaseId   String?
  createdAt          DateTime @default(now())
  description        String?
  notes              String?
  totalValue         String?
  value              String?
  invoice            Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId, date])
  @@map("purchases")
}

model Budget {
  id        String   @id @default(cuid())
  category  String
  month     Int      @default(0)
  year      Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  limit     String?
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([category, month, year, userId])
  @@index([userId, month, year])
  @@map("budgets")
}

model RecurringExpense {
  id             String    @id @default(cuid())
  category       String
  dueDay         Int       @default(1)
  isActive       Boolean   @default(true)
  lastLaunchedAt DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  userId         String
  description    String?
  notes          String?
  value          String?
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("recurring_expenses")
}

model FinancialGoal {
  id            String             @id @default(cuid())
  name          String
  description   String?
  category      GoalCategory
  targetDate    DateTime?
  icon          String?
  color         String             @default("#8B5CF6")
  isCompleted   Boolean            @default(false)
  completedAt   DateTime?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  userId        String
  currentValue  String?
  targetValue   String?
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  contributions GoalContribution[]

  @@index([userId])
  @@index([userId, isCompleted])
  @@index([userId, category])
  @@map("financial_goals")
}

model GoalContribution {
  id        String        @id @default(cuid())
  goalId    String
  date      DateTime
  createdAt DateTime      @default(now())
  notes     String?
  value     String?
  goal      FinancialGoal @relation(fields: [goalId], references: [id], onDelete: Cascade)

  @@index([goalId, date])
  @@map("goal_contributions")
}

enum TransactionType {
  income
  expense
}

enum InvestmentType {
  stock
  fii
  etf
  crypto
  cdb
  treasury
  lci_lca
  savings
  other
}

enum InvoiceStatus {
  open
  closed
  paid
  overdue
}

enum GoalCategory {
  emergency
  travel
  car
  house
  education
  retirement
  other
}

enum FeedbackType {
  bug
  suggestion
  other
}

enum FeedbackStatus {
  pending
  reviewing
  resolved
  closed
}

model Feedback {
  id            String         @id @default(cuid())
  type          FeedbackType
  description   String
  attachments   String[]
  status        FeedbackStatus @default(pending)
  adminResponse String?
  respondedAt   DateTime?
  userId        String
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  @@index([userId])
  @@index([status])
  @@map("feedbacks")
}

model Notification {
  id        String             @id @default(cuid())
  title     String
  message   String
  type      NotificationType
  userId    String?            // null = global, set = personal notification
  user      User?              @relation(fields: [userId], references: [id], onDelete: Cascade)
  metadata  Json?              // Extra data (feedbackId, etc)
  expiresAt DateTime?
  isActive  Boolean            @default(true)
  createdAt DateTime           @default(now())
  readBy    NotificationRead[]

  @@index([userId])
  @@index([isActive, createdAt])
  @@map("notifications")
}

model NotificationRead {
  id             String       @id @default(cuid())
  userId         String
  notificationId String
  readAt         DateTime     @default(now())
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  notification   Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)

  @@unique([userId, notificationId])
  @@index([userId])
  @@map("notification_reads")
}

enum NotificationType {
  feature          // Nova funcionalidade
  fix              // Correção de bug
  alert            // Alerta importante
  info             // Informação geral
  feedback_response // Resposta do admin ao feedback
  feedback_status   // Mudança de status do feedback
}
